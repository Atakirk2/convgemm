/**
 * Convolution tester
 *
 * Compares the matrices generated by the naive convolution against the
 * im2col+gemm, and against the convGemm approaches.
 *
 * Copyright 2020 Universitat Politècnica de València
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author P. San Juan
 * @date 2020-11
 *
*/

#include "convCommon.h"
#include "convGemm.h"

/**
 * Compares two matrices and returns their difference.
 *
 * @param m Rows of matrices.
 * @param n Cols of matrices.
 * @param M First matrix.
 * @param ldm Leading dimension of M.
 * @param M2 Second matrix.
 * @param ldm2 Leading dimension of M2.
 * @return |N-M2|_F/|M2|_F
 * */
float compareMatrix(const int m, const int n, float *M, const int ldm,
                    float *M2, const int ldm2)
{
    float norm = 0, normM2 = 0;
    
    bli_snormfv(m * n, M2, 1, &normM2);
    
    if(normM2 == 0)
        printf("WARN norm(M2) = 0\n");
    
    bli_ssubm(0, BLIS_NONUNIT_DIAG, BLIS_DENSE, BLIS_NO_TRANSPOSE, m, n,
              M, 1, ldm, M2, 1, ldm2);
    bli_snormfv(m * n, M2, 1, &norm);

    return norm / normM2;
}

/**
* Compares the matrices generated by the naive convolution against the
* im2col+gemm, and against the convGemm approaches.
*/
int main(int argc, char **argv)
{
    double tConv = 0.0, tIm2Col = 0.0, tIm2ColGemm = 0, tImp = 0.0, tIni,
        perfPeak, perfGemm, perfImp;

    float ONE = 1, ZERO = 0;

    int i, m, n, k,
        repe, // repetitions
        iZERO = 0;

    int h, w, c, b, // input dimensions
        ho, wo,  // output dimensions
        kh, kw, kn, // kernel dimensions
        stride, pad; // algorithm parameters
        
    char trans;

    float *F, *In,
        *OutConv, *OutI2c, *OutImp,
        *Aux,
        *Ac_pack, *Bc_pack;

    if(argc < 11) 
    {
        printf("Usage: %s <h> <w> <c> <b> <kh> <kw> <kn> <stride> <pad> <repetitions>\n\n", argv[0]);
        printf("Comparison of Convolution implementations.\n\n");
        printf("Parameters:\n");
        printf("  h, w, c     Input tensor dimensions dimensions.\n");
        printf("  b           Batch size.\n");
        printf("  kh, kw      Kernel dimensions.\n");
        printf("  kn          Number of kernels.\n");
        printf("  stride      Kernel application stride.\n");
        printf("  pad         Input padding (ignored, no padding is done).\n");
        printf("  repetitions Number of times each test will be repeated.\n");
        return -1;
    }

    h = atoi(argv[1]);
    w = atoi(argv[2]);
    c = atoi(argv[3]);
    b = atoi(argv[4]);
    kh = atoi(argv[5]);
    kw = atoi(argv[6]);
    kn = atoi(argv[7]);
    stride = atoi(argv[8]);
    pad = atoi(argv[9]);
    repe = atoi(argv[10]);
    if(argc == 11)
        trans = 'N';
    else
        trans = *argv[11];

    
    
    printf("Allocating matrices...\n");


    ho = floor((h - kh + 2 * pad) / stride + 1);
    wo = floor((w - kw + 2 * pad) / stride + 1);
    
        // Input matrices
    In = (float *) malloc(h * w * c * b * sizeof(float));
    

    // Auxiliary matrices
    alloc_pack_buffs( &Ac_pack, &Bc_pack);
    Aux = (float *) malloc(c * kh * kw * ho * wo * b * sizeof(float));



    printf("Generating random matrices...\n");
    bli_srandm(0, BLIS_DENSE, b, h * w * c, In, 1, b);


    if(trans == 'N')
    {
        F = (float *) malloc(kh * kw * c * kn * sizeof(float));
        bli_srandm(0, BLIS_DENSE, kn, kh * kw * c, F, 1, kn);
        
        // Output matrices
        OutConv = (float *) malloc(ho * wo * kn * b * sizeof(float));
        OutI2c = (float *) malloc(ho * wo * kn * b * sizeof(float));
        OutImp = (float *) malloc(ho * wo * kn * b * sizeof(float));
    
        printf("Starting the evaluation...\n");
        for(i = 0; i < repe; i++)
        {
            // Timing naive convolution
            tIni = bli_clock();
            convolutionNaive(h, w, c, b, In, kh, kw, kn, F, OutConv, stride);
            tConv += bli_clock() - tIni;

            // Timing im2col+gemm
            tIni = bli_clock();
            im2Col(h, w, c, b, In, kh, kw, stride, Aux);
            tIm2Col += bli_clock() - tIni;
            bli_sgemm(BLIS_NO_TRANSPOSE, BLIS_NO_TRANSPOSE, kn, ho * wo * b,
                        kh * kw * c, &ONE, F, 1, kn, Aux, 1, kh * kw * c, &ZERO,
                        OutI2c, 1, kn);
            tIm2ColGemm += bli_clock() - tIni;

            // Timing convgemm
            tIni = bli_clock();
            sconvGemm('N',kh, kw, c, kn, 1, F, h, w, b, stride,stride, In, 0, OutImp,
                        Ac_pack, Bc_pack);
            tImp += bli_clock() - tIni;
        }
    }
    else
    {
        F = (float *) malloc(ho * wo * b * kn * sizeof(float));
        bli_srandm(0, BLIS_DENSE, kn, ho * wo * b, F, 1, kn);
        
        // Output matrices
        OutI2c = (float *) malloc(kh * kw * c * kn  * sizeof(float));
        OutImp = (float *) malloc(kh * kw * c * kn  * sizeof(float));
        
        
            // Timing im2col+gemm

        for(i = 0; i < repe; i++)
        {
            tIni = bli_clock();
            im2Col(h, w, c, b, In, kh, kw, stride, Aux);
            tIm2Col += bli_clock() - tIni;
            bli_sgemm(BLIS_NO_TRANSPOSE, BLIS_TRANSPOSE, kn, kh * kw * c,
                        ho * wo * b, &ONE, F, 1, kn, Aux, 1, kh * kw * c, &ZERO,
                        OutI2c, 1, kn);
            tIm2ColGemm += bli_clock() - tIni;
        }
        

            // Timing convgemm
        tIni = bli_clock();
        for(i = 0; i < repe; i++)
        {
            sconvGemm('Y',kh, kw, c, kn, 1, F, h, w, b, stride,stride, In, 0, OutImp,
                        Ac_pack, Bc_pack);
        }
        tImp = bli_clock() - tIni;
        
    }
    
    tConv /= repe;
    tIm2Col /= repe;
    tIm2ColGemm /= repe;
    tImp /= repe;

    perfImp = (2.0 * kn * ho * wo * b * kh * kw * c) / (tImp * 1.0e9);
    perfGemm = (2.0 * kn * ho * wo * b * kh * kw * c) / ((tIm2ColGemm - tIm2Col) * 1.0e9);

    printf("Naive convolution time: %.4g \n", tConv);
    printf("im2Col + Gemm time: %.4g [Im2Col: %.4g , Gemm: %.4g] GFLOPS(gemm): %.5g \n",
           tIm2ColGemm, tIm2Col, tIm2ColGemm - tIm2Col, perfGemm);
    printf("convGemm time: %.4g GFLOPS: %.5g\n", tImp, perfImp);

  
    if(trans == 'N')
    {
        printf("norm(OutIm2col-OutConvgemm): %g\n",
           compareMatrix(kn, ho * wo * b, OutI2c, kn, OutImp, kn));
        printf("norm(OutIm2col-OutNaive): %g\n",
           compareMatrix(kn, ho * wo * b, OutI2c, kn, OutConv, kn));
        free(OutConv);
    }
    else
        printf("norm(OutIm2col-OutConvgemm): %g\n",
           compareMatrix(kn, kh * kw * c, OutI2c, kn, OutImp, kn));


    free(In);
    free(F);
    free(OutI2c);
    free(OutImp);
    free(Aux);
    free(Ac_pack);
    free(Bc_pack);
}

